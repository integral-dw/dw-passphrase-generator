#+TITLE: ~dw~: A Diceware Passphrase Generator for Emacs
#+STARTUP: showall

[[https://xkcd.com/936/][file:https://imgs.xkcd.com/comics/password_strength.png]]

* Table of Contents
  * [[#About][About]]
  * [[#how-to-use-this-package][How to Use This Package]]
  * [[#Installation][Installation]]
  * [[#Customization][Customization]]
  * [[#planned-features][Planned Features]]

* About
  :PROPERTIES:
  :CUSTOM_ID: About
  :END:

  *WARNING:* This package is under construction.  Once again, I am busy
  working out the kinks.  *Any function and variable defined here is
  subject to change* until version 1.0.0, from which point on I will
  try my best not to inconvenience people.

  This package provides a basic implementation of the [[http://world.std.com/~reinhold/diceware.html][diceware]] method
  of passphrase generation, by Arnold G. Reinhold.  If you are new to
  diceware, *please read the subsections below, or check out the link
  above*.

  A minor disclaimer: I am not an expert on encryption, cybersecurity,
  infosec, psychology or information theory.  But I do have a
  mathematically solid enough background to /understand/ explanations,
  remarks and arguments regarding password security fundamentals.  So
  if anything in this README is badly explained, half-true or plain
  wrong, please consider opening an issue.

** What does this package do?
   All it really does is automate away the table lookup part of the
   diceware method, so you don't have to =C-s= every five rolls.  In
   other words, the core premise of this package is so simple, it
   could snugly fit into less than 150 LOC.  Add safety checks, core
   facilities for translating die rolls to random integers of
   nigh-arbitrary range, a few public API functions and a couple of
   customizable bits, and you're left with a factor of 2-4 of that.

** What is diceware?
   In short, diceware is a way of generating secure passphrases.
   While this README will briefly describe the basics, it does not try
   to replicate the original [[https://theworld.com/~reinhold/diceware.html][home page]].

** What is a passphrase, and why should I use it?
   If a password is a sequence of random characters, a passphrase is
   simply a sequence of random words.  In this context, a "word" can
   be a proper word from a real language, or a short sequence of
   random characters.  See the above comic for a simple example of
   (bad) passwords versus simple passphrases.  A few of the selling
   points of passphrases are:

   * They are easier to memorize.
   * They are easy to generate (even without this package).
   * They are prescriptive: Roll dice, go through the list, write down
     the word, repeat.  Everything about the method is
     straightforward.

** What is a wordlist and why do I need one?
   Unlike passwords, which draw from a random pool of characters for
   security, diceware passphrases draw from a random pool of words.  A
   wordlist associates five die rolls with a single word, meaning
   every regular wordlist is 6^5 or *7776* words long.  While there are
   wordlists with fewer dice, I see very little point supporting them,
   as it just means having to roll more words for the same security.
   While there are fancy wordlists in PDF and other formats, ~dw~ is
   limited to plain text.  Here is a small excerpt from one of the
   wordlists linked in the [[#Installation][Installation]] section, as a simple example
   of how a supported wordlist looks like:

   #+begin_example
   36166	limb
   36211	limeade
   36212	limelight
   36213	limes
   36214	limit
   36215	limping
   36216	limpness
   36221	line
   36222	lingo
   36223	linguini
   #+end_example

   And so on.  In other words, a wordlist is a plain text file where
   each line begins with a unique sequence of dice rolls, followed by
   whitespace, followed by the word to replace the specific result
   with.

** What makes a passphrase secure?
   As described above, a passphrase draws from a pool of random words,
   not random characters.  A simple way of measuring security is
   called /entropy/, which is defined as the base 2 logarithm of the
   number of possible outcomes for a generated passphrase.  So it
   essentially measures the expected order or magnitude of guesses an
   attacker would need /even if/ they knew how the passphrase was
   generated.  Since the number of possibilities grows
   multiplicatively with the number of words added, the entropy grows
   additively.  A password generated by picking a random sequence of
   printable ASCII characters has ~log2(95)~ or \approx6.6 "bits" of entropy
   per character.  Likewise, a passphrase has ~5*log2(6)~ or \approx12.9 bits
   of entropy per word, meaning a six-word passphrase is about the
   same quality as a perfectly random string of 12 printable
   characters, a seven word passphrase is equivalent to 14.  The
   trade-off that arises is between having to /type/ "fill 33rd chi
   drury behind chick fade" and having to /remember/ "9W]OZ<D`zBnDpf".

** What are the limitations of diceware?
   There are two relevant factors: The first is arbitrary restrictions
   such as the password requiring at least one numeral, uppercase
   letter or special character.  This problem can be easily overcome
   by random character insertion or adding salt (neither of which is
   currently implemented, but explained [[https://theworld.com/%7Ereinhold/dicewarefaq.html][here]]).

   The other problem is a limited password length.  If the system you
   need a password for does not let you exceed a limit of 15
   characters, you're basically stuck with random character strings
   and ideally drawing from a large alphabet of characters.

   *Remark:* If your passphrase approximates a known phrase, drop it,
   and re-roll.  The chance of such a passphrase being generated is
   astronomically low, but every sensible attacking strategy would try
   common phrases.

** Can't I just guess numbers instead of rolling dice?
   *NO*.  The human perception of randomness is immensely skewed, and
   rather predictable.  Humans are too good at recognizing patterns,
   so people are not going to produce the sequences "22226" and
   "13426" with equal probability.  One somehow feels "more random"
   than the other, doesn't it?  The diceware homepage (linked above)
   also has recommendations for cases where dice are not available.

* How to Use This Package
  :PROPERTIES:
  :CUSTOM_ID: how-to-use-this-package
  :END:
  Once the package is set up (see [[#Installation][Installation]]), basic usage boils
  down two three simple steps:

  1) Open a temporary buffer. For example, =C-x b dice RET= opens a
     buffer called =dice=.  This way you can easily dispose of the
     buffer once you got your passphrase.
  2) Roll your dice, reading them in some consistent way (e.g. left to
     right) every time, and typing them neatly separated in groups of
     five.  You can separate them using any character matched by
     ~dw-separator-regexp~ (whitespace by default).  For example, if you
     rolled ⚄⚂⚀⚅⚅, type =53166=.  You will need five times as many die
     rolls as you want words in your passphrase (six being a decent
     amount for normal passphrases).
  3) Mark the region where you wrote down your sequence of rolls and
     enter =M-x dw-passgen-region RET=.  You may need to choose a
     wordlist depending on your setup (see [[#Customization][Customization]] below for how
     to skip this step and set up a default wordlist).

     And you're done!  Copy the passphrase into a safe location, kill
     the buffer, and potentially purge the passphrase from your kill
     ring.  If it is /really/ important, write it down and store it with
     other sensitive documents.

     This package has a few additional extras allowing you to script
     your own passphrase generator without needing to worry about
     implementing safety-checks, wordlist parsing and lookup, as well
     as a few more interactive niceties.  See below for a full
     overview.

** Interactive commands
   There are two simple interactive commands at the moment, with one
   or two more planned in future versions.

*** ~dw-passgen-region (start end &optional choose-wordlist)~
    The all-in-one interactive passphrase generation command, and most
    likely everything you'll ever need from this package.  Just mark
    the region containing your written down die rolls and run the
    command.  With a prefix argument ~choose-wordlist~, this command
    prompts for a wordlist to use regardless of whether a default
    wordlist has been specified.  For more on default wordlists, see
    ~dw-named-wordlists~ [[#Customization][below]].

*** ~dw-set-wordlist (&optional use-default)~
    Manually set a wordlist without invoking ~dw-passgen-region~, and
    regardless of whether a wordlist has been set for the current
    buffer before.  The prefix argument works largely the same as that
    of ~dw-passgen-region~, but with the default reversed, since it's
    more likely you want to change the wordlist regardless of defaults
    when you go out of your way invoking an extra command to do just
    that.

** Public functions
   =dw= uses very primitive data structures to hold wordlists and
   internalized passphrases.  Wordlists are internalized as
   association lists with die rolls converted to an internal integer
   format.  The primary retrieving functions for this association list
   are ~dw-generate-passlist~ and ~dw-generate-passphrase~ both of which
   provide additional checks for safe passphrase generation.

   The internal representation of a passphrase (called a /passlist/) is
   a simple list of words the passphrase is composed of, in order.

*** ~dw-build-alist (path &optional default-dir coding noerror)~
    This function serves to internalize and store a wordlist from
    within Lisp.  ~dw-set-wordlist~ is a more special case of this,
    being solely called for the side effect of setting up
    ~dw-current-wordlist~, which interactive commands should use to
    store the most recently used wordlist in.

    This function signals the following =dw=-specific error:
    * =dw-bad-wordlist=

*** ~dw-generate-passlist (string alist &optional noerror)~
    Internalize a given die string to a passlist for a given wordlist.
    If the resulting passphrase has an extraordinarily low character
    count (to the point that a program brute-forcing every character
    combination would outperform a wordlist-based attack), this
    function reports a warning.

    This function signals the following =dw=-specific errors:
    * =dw-bad-roll=
      + =dw-too-short-passphrase=
      + =dw-incomplete-roll=

*** ~dw-generate-passphrase (string alist &optional separator strfun)~
    A thin wrapper for ~dw-generate-passlist~, concatenating the
    passlist into a complete passphrase.  ~strfun~ allows you to apply
    an arbitrary string function to each word before concatenation.
    This is what ~dw-passgen-region~ uses to capitalize each word in a
    passphrase.

    This function signals the following =dw=-specific errors:
    * =dw-bad-roll=
      + =dw-too-short-passphrase=
      + =dw-incomplete-roll=

*** ~dw-required-dice (n)~
    The minimum number of dice necessary to decide between /n/ possible
    outcomes.  The function itself is trivial, and only serves as a
    convenience to catch input errors before passing a string to
    ~dw-generate-ranint~.

*** ~dw-generate-ranint (string maxint &optional noerror)~
    This function supports using dice to decide between =maxint=
    possible outcomes.  It takes a string of die rolls and converts it
    to an integer between 0 (inclusive) and =maxint= (exclusive).

    *Note:* If =maxint= is not a number of the form 2^{a}\cdot3^{b},
    ~dw-generate-ranint~ has a finite chance of failing (different from
    raising an error).  This is unavoidable without silently
    increasing the odds of some values.  In such cases, the function
    returns ~nil~.

    This function signals the following =dw=-specific errors:
    * =dw-bad-roll=
      + =dw-incomplete-int=
    * =dw-overflow=

** Error types
   This package defines a couple of errors, most of which may be
   recovered from gracefully.

*** =dw-bad-wordlist=
    The wordlist cannot be used for passphrase generation.  Several
    things may cause this error: The wordlist being too short, too
    long, not a regular file, or missing a key.  What data the error
    holds depends on what went wrong:

    * Is the wordlist too long, it will hold a list of the form ~(>
      IS-LENGTH GOAL-LENGTH)~, where =IS-LENGTH= is the actual length of
      the wordlist, while =GOAL-LENGTH= is the length the list should
      have.  Conversely, if the wordlist is too short, it will hold a
      list ~(< IS-LENGTH GOAL-LENGTH)~.
    * If the wordlists is missing an entry, for example the
      combination "16452", it will hold this combination as a string.
    * If the file is not a regular file (e.g. a directory) it holds
      the predicate ~file-regular-p~ and name of the file.

*** =dw-bad-roll=
    The string of die rolls cannot be parsed for some reason.  More
    specific errors inherit from it.  If signaled on its own, the
    string contains an invalid character.  The available data is the
    first invalid character, as a string.

*** =dw-incomplete-roll=
    The number of dice rolled is not a multiple of five (or zero).  It
    holds two integers for data, the number of dice found and the
    nearest multiple of five, rounded up.  Its parent is =dw-bad-roll=.

*** =dw-too-short-passphrase=
    The number of words rolled is low enough to pose a security
    threat.  The minimum number of words is set by
    ~dw-minimum-word-count~, which see.  The error holds two integers
    for data, the number of words the current passphrase would have
    and the set minimum.  Its parent is =dw-bad-roll=.

*** =dw-incomplete-int=
    The number of dice rolled is less than the theoretical minimum to
    uniformly sample a given range of numbers.  Like
    =dw-incomplete-roll=, this error holds two integers: the number of
    rolls found and the theoretical minimum required.  Its parent is
    =dw-bad-roll=.

*** =dw-overflow=
    =dw-generate-ranint= is very primitively implemented, intermediately
    converting the given string of die rolls into a base 6 integer.
    This is quite inefficient for 10+ die rolls.  Even worse, there is
    absolutely no point in requiring two extra words worth of dice for
    a single extra operation.  Hence, this error is raised should the
    number of dice for a single operation exceed 10.

* Installation
  :PROPERTIES:
  :CUSTOM_ID: Installation
  :END:

  Since this packages relies on external files, a minimum installation
  requires two (plus a third, optional) steps:

  1) Put =dw.el= into your load path.
  2) Put a wordlist for passphrase generation into the directory
     specified by ~dw-directory~ (see the section [[#Customization][Customization]] for
     more).  You can find English wordlists [[https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt][here]] and [[http://world.std.com/%7Ereinhold/diceware.wordlist.asc][here]].  The former
     generates passphrases with long, common words while the latter
     favors short words and letter combinations, which may be harder
     to remember but quicker to type.  You can find wordlists for many
     other languages [[http://world.std.com/~reinhold/diceware.html#Diceware%20in%20Other%20Languages|outline][here]].  See the section [[Wordlists]] for more details
     on what kind of wordlists =dw= expects.
  3) /(optional)/ Set up ~dw-named-wordlists~ (see the section
     [[#Customization][Customization]] below).

* Customization
  :PROPERTIES:
  :CUSTOM_ID: Customization
  :END:

** ~dw-directory~
   The wordlist directory.  Upon load, this package automatically
   generates whichever directory this variable is set to, if it
   doesn't exist yet.  The default directory is =~/.emacs.d/diceware=,
   or a system-specific equivalent thereof.  You can either customize
   or set this variable manually.

   *Note:* Setting this variable outside of custom (for example with
   ~setq~) must be done /before/ the package is loaded if you want to have
   the directory auto-generated.  Otherwise, =dw= will generate the
   default directory instead.

** ~dw-named-wordlists~
   By default, ~dw-passgen-region~ will prompt you for a wordlist file
   to use.  However, most of the time you'll want to use the same
   wordlist.  For this reason, this package lets you define /named
   wordlists/ to speed up the selection process.

   ~dw-named-wordlists~ is an association list where each entry is of
   the form ~(NAME FILE . CODING)~ or simply ~(NAME FILE)~.  ~NAME~ should
   be a symbol.  ~FILE~ should be the filename of the wordlist, either
   relative to ~dw-directory~ or absolute.  ~CODING~ should be the
   encoding of the file, with ~nil~ being treated as ~utf-8~.

   The symbol ~default~ is a special wordlist name: if used, this
   wordlist will be selected by default without prompting the user.

** ~dw-separator-regexp~
   Regular expression matching a single separator character.  All
   characters matching this regexp are ignored when reading die rolls,
   making them valid separators for noting down.  Separators are
   useful for visually grouping die rolls.  For example, the string

   "13524 23621 63622"

   is more clearly a set of 15 die rolls than "135242362163622".
   Customize this value to include whichever characters you fancy.
   For example, use ~(setq dw-separator-regexp "\\(\\s-\\|[.,-]\\)")~ to
   also allow for periods, dashes and commas.

** ~dw-passphrase-separator~
   By default, the words making up the passphrase generated by
   ~dw-passgen-region~ are separated by spaces.  This is done to prevent
   word collisions (cases where two words concatenated yield another
   valid word, like "in"+"put" \to "input").  You can change the
   separator by setting this variable, or omitting it entirely (using
   the empty string).  Ultimately, the choice of separator makes very
   little difference.  It is, however, best to choose a separator /once/
   and stick to it, or else it becomes additional needless information
   to memorize, which the diceware method tries to keep to a minimum.

** ~dw-capitalize-words~
   One of the more common restrictions put on passphrases is the
   requirement of at least one capital letter.  However, the entropy
   gained from random capitalization is not worth the effort unless
   you are dealing with a tight character limit for your passphrase
   (at which point you are basically stuck using random character
   strings for decent security anyway).  So this option simply
   capitalizes every word in your passphrase.  As with setting a
   separator (see above), you should use /one/ way of capitalization and
   stick to it.  It makes no sense to change this variable often, as
   this turns a convenience into a burden to remember.

   *Remark:* The [[http://world.std.com/%7Ereinhold/dicewarefaq.html][original FAQ]] recommends randomly capitalizing one word
   in the passphrase to fulfill this condition.  Since there is hardly
   a way to implement this in a way taking fewer key strokes than it
   would take to do it manually, this option is not implemented.

** ~dw-minimum-word-count~
   As technology marches on, passphrases need to become harder to
   guess to prove effective.  This variable ensures that you don't
   create an insufficiently long passphrase by accident.  The current
   value is 5, corresponding to the number of words of a sub-par
   passphrase.  You may want to set this value to 6 to be on the safe
   side.

   *Note:* There is no real point in setting this variable any lower (or
   higher) than 5-7.  You would either render the passphrase insecure
   by admitting smaller passphrases (useless), or create such
   ridiculously high-security passphrases that the weakest link in
   your security shifted elsewhere: /A fifth bolt on your front door
   won't do you any good if you keep your ground floor windows open./

* Planned Features
  :PROPERTIES:
  :CUSTOM_ID: planned-features
  :END:

  This package has gone through a couple of iterations over the years.
  I have been keeping variations of it around for probably almost as
  long as I use Emacs.  If this package ever tried to teach me
  anything, it is "less is more": Well, it should have tried harder.

  For now, there are two things on the schedule:
  + add support for salt
  + add support for random char insertion

#  LocalWords:  wordlist wordlists infosec passlist alist dw drury el
#  LocalWords:  passgen linguini log2 RET dir noerror strfun ranint
#  LocalWords:  maxint setq utf
